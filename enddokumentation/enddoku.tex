\documentclass[10pt]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{hhline}
\usepackage{url}
\usepackage[backend=biber,style=numeric-comp]{biblatex}


\usepackage[acronym, toc]{glossaries}
\makeglossaries
\input{glossary/glossary.tex}

\addbibresource{sample.bib}
\author{Dane Wicki}
\title{Universal data acquisition}
\subtitle{FS17 Praxismodul}
\renewcommand{\contentsname}{Inhaltsverzeichnis}
\begin{document}
\maketitle
\tableofcontents
\section{Einleitung, Problembeschreibung}
\subsection{Geschäftsfeld der Firma}
Die Siemens AG ist ein führender internationaler Technologiekonzern, der seit mehr als 165 Jahren für technische Leistungsfähigkeit, Innovation, Qualität, Zuverlässigkeit und Internationalität steht. Das Unternehmen ist in mehr als 200 Ländern aktiv, und zwar schwerpunktmäßig auf den Gebieten Elektrifizierung, Automatisierung und Digitalisierung. Siemens ist weltweit einer der größten Hersteller energieeffizienter ressourcenschonender Technologien. Das Unternehmen ist einer der führenden Anbieter effizienter Energieerzeugungs- und Energieübertragungslösungen, Pionier bei Infrastrukturlösungen sowie bei Automatisierungs-, Antriebs- und Softwarelösungen für die Industrie. Darüber hinaus ist das Unternehmen ein führender Anbieter bildgebender medizinischer Geräte wie Computertomographen und Magnetresonanztomographen sowie in der Labordiagnostik und klinischer IT. \cite{website:siemens}
\subsection{Projektkontext}
Die Firma Siemens BT in Zug ist zuständig für die Entwicklung von Brandmeldern.
Um die Qualität der Brandmelder zu gewährleisten, werden diese unter Zuhilfenahme
verschiedener Apparaturen und Testaufbauten getestet. Dies geschieht bei vielen Aufbauten automatisch und mit konsistenter Aufzeichnung der Daten, welche der Melder und etwaige Referenz-Geräte erzeugen. Es gibt jedoch weiterhin aufbauten, bei welchen die Aufzeichnung weder Automatisch noch Konsistent gespeichert werden kann oder nur unter grossen Anstrengungen der Arbeitenden. Diesen Zustand gilt es nun zu verbessern.
Dazu soll eine Software entwickelt werden, die aus verschiedenen Ressourcen (verschiedenen
Datenquellen) die Daten sammelt und diese in eine auswertbare Excel-Datei exportiert. Dies
Software basiert auf einer bestehenden Software, welche für das Brandlabor entwickelt wurde.
Es sollen dabei Bestandteile dieser Bestehenden Software verwendet werden.
\subsection{Problembeschreibung}
\subsection{Projektziele}
Bei vielen kleinen Aufbauten ist keine oder nur teilweise Software, welche die zu sammelnden Daten zusammenträgt. Dieser Mangel an Software führt dazu, dass nur auf umständliche Art und weise getestet werden kann. Dies stellt eines der Probleme dar. Dieser Umstand führt zudem zu einem erhöhten Zeitaufwand bei einer Durchführung eines Testdurchlaufes. Hinzu kommt, dass es einige Aufbauten gibt, welche sehr selten bis nie gebraucht werden. Der fehlende Zyklische Gebrauch jener Aufbauten führt zu einer erhöhten Einarbeitungsperiode, da die Person die Handhabung der Aufzeichnung zuerst wieder erlernen muss. Diese Einarbeitungsperiode sowie der erhöhte Zeitaufwand für einen Testdurchlauf soll durch eine Vereinheitlichung beseitigt werden. Dazu soll die Software an möglichst allen Aufbauten eingesetzt werden können, welche keine eigene Spezielle Software besitzen.

Ein weiteres Problem stellt eine Anpassung einer \gls{UL}-Norm dar. Diese Anpassung betrifft einige Siemens Brandmelder, welche schon im Feld sind. Da die Siemens bis anhin keine Möglichkeiten hat diese Angepasste Norm zu testen, wurde eine neue Testapparatur bestellt. Im Rahmen der Bestellung wurde jedoch nur die Apparatur zum Testen bestellt, keine Passende Software, welche alle Daten während eines Testlaufes aufzeichnen könnte. Ziel ist es die Software mit Ankunft der Apparatur in Betrieb nehmen zu können.
\section{Projektergebnisse}
\subsection{Ergebnisse}
Die folgenden Ergebnisse müssen im Rahmen dieses Projektes erarbeitet werden:
\begin{itemize}
	\item DB Skripte für die Erstellung der Datenbank
	\item Endsoftware
	\item Installationsanleitung
	\item Bedienungsanleitung
	\item SW-Dokumentation
\end{itemize}
\subsection{Anforderungen}
Die Folgenden Punkte muss die Software Erfüllen.
\begin{itemize}
	\item Name des neuen Programmes ist "\textbf{U}niversal \textbf{d}ata \textbf{a}cquisition" \acrshort{uda}
	\item Das Programm muss auf Win7, 8.1, ... laufen.
	\item Modularer Aufbau
	\item Alle angaben sollen auf Ihre Plausibilität überprüft werden.
	\item Bei Falschen, und undefinierten "Objekten" sollen Fehlermeldungen mit Angabe der Fehlerquelle aufgelistet werden.
	\item Programmeinstellungen sollen in einer ini-Datei gespeichert werden.
	\item Die Installation soll mit einem Installer geschehen.
	\item Bestehende Funktionalitäten sollen übernommen werden.
	\item Die Software muss in \gls{LabVIEW} geschrieben werden.
\end{itemize}
\section{Umsetzung}
\subsection{Verwendete Tools}
Für die Entwicklung wurde folgende Software verwendet:
\begin{itemize}
	\item LabView 2014SP1 (Version 14.0.1f3 32bit)
	\item OpenGDS v1.0.37(32 bit)
	\item OpenG v4.0.1.9(32 bit)
	\item MySQL ODBC 5.2.6(32bit)
	\item MySQL ODBC 5.2.6(64bit)
	\item MySQL Server 5.7.14
	\item MySQL Workbench 6.3.6
\end{itemize}
\subsubsection{LabView}
\begin{wrapfigure}{r}{0.7\textwidth}
	\begin{center}
		\includegraphics[width=0.6\textwidth]{LabVIEWExample}
		\caption{Beispiel LabView\gls{VI} mit Beschreibung}
		\label{fig:LabViewExample}
	\end{center}
\end{wrapfigure}
\gls{LabVIEW} ist eine grafische Programmiersprache, welche von National Instruments entwickelt wird. Die Funktionsweise von \gls{LabVIEW} ist zudem sehr speziell, da es Funktionsblöcke gib, welche Virtuelle Instrumente (\gls{VI}s) bezeichnet werden. Man kann sich die \gls{VI}s als Funktionen oder Methoden vorstellen. Sie besitzen immer ein \gls{Frontpanel} sowie ein \gls{Blockdiagramm}, in welchem auch der Code zu finden ist (Siehe Figure \ref{fig:LabViewExample}). Zudem unterstützt \gls{LabVIEW} seit geraumer Zeit Objektorientiertes Programmieren, dies jedoch nur unzulässig und sehr eingeschränkt.
\newline
Die mangelden fähigkeit zu Objektorientierter Programmierung, fürt zu dem Umstand, dass an machen orten mit einer anderen Art und Weise angegangen werden muss, wie man es sich von Objektorientierten Programmieren gewohnt ist. Zudem sind \gls{LabVIEW} Programme nicht sonderlich schnell, weshalb besonders stark auf die Performance zu achten ist.
\newline
Eine weitere Sonderheit ist die Verknüpfung von GUIs mit dem Programm, es besteht eine sehr starke verknüpfung zwischen der funktion und dem GUI.Dies bietet einige Vor- wie auch Nachteile. So wird in diesem Projekt stark mit \gls{Subpanel}s gearbeitet, welches die Möglichkeit liefert dynamisch GUIs von anderen\gls{VI}s in das laufende Programm einzubinden.  \cite{website:labView} 


\subsection{Software}
\begin{wrapfigure}{l}{0.65\textwidth}
	\begin{center}
		\includegraphics[width=0.6\textwidth]{SystemviewFTC}
		\caption{Systemview des Fire Test Commander}
		\label{fig:SystemViewFTC}
	\end{center}
\end{wrapfigure}
\subsubsection{Bestehende Software}
Im Rahmen des Umzuges der Testabteilung, wurden die Brandräume neu gebaut. Während des Baus wurde zudem die veraltete Software, welche für die Alten Brandräume erstellt wurde, durch eine neue ersetzt. Die neu erstellte Software, welche unter dem Namen Fire Test Commander fortan nur noch \acrshort{ftc}, wurde mit \gls{LabVIEW} erstellt. Diese Software hat schon viele Ansätze, welche für die im Rahmen dieses Projektes zu implementierendes Programm angewandt und übernommen werden können. Der \acrshort{ftc} bietet schon eine Struktur, um mit möglichst geringen aufwand Hardwarekomponenten hinzuzufügen (Siehe Figure \ref{fig:SystemViewFTC}). Diese Struktur, dient zudem gleich als Vorlage für die neu zu entwickelnde Software.
\begin{wrapfigure}{r}{0.5\textwidth}
		\begin{center}
			\includegraphics[width=0.35\textwidth]{Systemgrenzen}
			\caption{Systemabgrenzung der einzelnen Komponenten}
			\label{fig:SystemView}			
		\end{center}
\end{wrapfigure}
\subsubsection{Systemgrenzen}
Da die Hardware Abstraktion komplett von der bestehenden Software übernommen werden kann, fällt diese aus dem Projekt heraus. Nur die UDA selber, soll als eigenständige Software entwickelt werden. Die Abgrenzung des Systemes kann in folgender Abbildung (Figure \ref{fig:SystemView}) nachvollzogen werden.
 Die Datenbank ist eine MySQL Datenbank, welche mithilfe des ODBC ANSII Treibers Angesprochen werden kann. Die Schnittstelle wird von \gls{LabVIEW} zur Verfügung gestellt und musste auch nicht selber Implementiert werden.
\newline
\newline
\newline
\newline
\newline
\newline
\subsubsection{Komponente UDA}
Aufgrund von Performance gründen wurde die Software mit vielen verschiedenen Task ausgestattet. So ist jede GUI Komponente, welche auf dem Hauptprogramm aufrufbar ist ein eigener Thread,  welchen ihren eigenen Event-Handler besitzt. Die Gui Komponenten werden zur entsprechenden Zeit dynamisch in der Hauptkomponente als Subkomponenten geladen. Diese Komplexe Thread Struktur wird im Bild \ref{fig:LaufzeitansichtUDA} dargestellt. Diese Software struktur basiert auf dem Queued Message Handler Template von National Instruments.
Das Hauptprogramm (Main) besteht aus zwei parallelen Tasks
\begin{itemize}
	\item dem Event-Handler, der primär auf Eingaben vom Anwender reagiert
	\item und der Verarbeitungstask (Queued Message Handler), der die Aufträge aus seiner Message-Queue entnimmt und der Reihe nach abarbeitet.
\end{itemize}

Die Bedienoberfläche umfasst vier Subpanel-Vis. Diese werden im Hauptprogramm aufgerufen und laufen parallel zu den beiden Tasks des Hauptprogrammes. Das \gls{Frontpanel} eines dieser Subpanel-Vis wird programmatisch im Subpanel des Hauptprogrammes sichtbar gemacht.  
Jedes dieser Subpanel-Vis besitzt einen eigenen Event-Handler der auf Eingaben des Anwenders reagiert. Sowohl der Event-Handler des Hauptprogrammes wie auch diejenigen der Subpanel-Vis senden Messages an die Message-Queue der Verarbeitungstask im Hauptprogramm (In der Abbildung \ref{fig:LaufzeitansichtUDA} mit grünen durchgezogenen Pfeilen dargestellt).




\begin{wrapfigure}{r}{0.4\textwidth}
	\begin{center}
		\includegraphics[width=0.3\textwidth]{filterVI}
		\caption{Aufruf des FilterVIs}
		\label{fig:filterVI}
	\end{center}
\end{wrapfigure}
Die Im Bild \ref{fig:LaufzeitansichtUDA} dargestellten Pfeile stellen die Kommunikationswege dar. Es gibt insgesammt 2 Möglichkeiten der Kommunikation. Wie oben geschrieben gibt es die Message-Queue, mit welcher Messages an das Hauptprogramm gesendet werden können. Dieses wiederum kann mit allen anderen über ein User-Event (In der Abbildung \ref{fig:LaufzeitansichtUDA} mit orangen gestrichelten Pfeilen dargestellt) kommunizieren. Die User-Events werden an alle Event-Handler gesendet (Broadcast). Mit Hilfe eines Filter-Vis (siehe Figure \ref{fig:filterVI}) kann der empfangende Event-Handler die Events aber filtern, sodass er nur Events mit der richtigen Adresse (ID) verarbeitet.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{LaufzeitansichtMitRecorder}
	\caption{Laufzeitansicht der GUI Tasks und deren Kommunikation}
	\label{fig:LaufzeitansichtUDA}
\end{figure}
\newpage
\begin{wrapfigure}{r}{0.4\textwidth}
	\begin{center}
		\includegraphics[width=0.29\textwidth]{LauftzeitansichtRecorderNah}
		\caption{Kommunikation Main mit Recorder}
		\label{fig:LauftzeitansichtRecorder}
	\end{center}
\end{wrapfigure}
\subsubsection{Data Preparation \& Recorder}
Die Umsetztung setzte voraus, dass das Aufzeichnen aller Daten in einem immer gleich bleibenden Intervall aufgezeichnet werden. Dazu war nötig, dass für jede angeschlossene Hardware ein eigener Thread startet, welcher die Daten Zwischenspeichern kann. Um dies zu gewährleisten wurde ein Recorder-\gls{VI} erstellt, welches über einen Asynchronen Aufruf mehrmals gestartet werden kann. Die Kommunikation zu diesen \gls{VI}s findet vom Hauptprogramm über einen Speziellen Event an alle laufenden Recorder statt(Siehe Figure \ref{fig:LauftzeitansichtRecorder}). Dieser Event wird jedoch an keinen der anderen Task gesendet. Der Event lässst schliesslich alle Recorder starten. Dieses verhalten ist mit dem NotifyAll in Java vergleichbar, womit alle Thread zur selben Zeit gestartet werden können. 

\subsection{Datenbank}
\subsubsection{Bestehende Datenbank}
Mit der Implementierung der FTC Software wurde auch eine eigens dafür entwickelte Datenbank aufgebaut. Diese ist in sich enorm Komplex und sehr verstrickt, weshalb hier nicht viel näher auf diese eingegangen wird.
\subsubsection{Datenbank}
\begin{wrapfigure}{r}{0.65\textwidth}
	\begin{center}
		\includegraphics[width=0.6\textwidth]{DBShemaEasy2.png}
		\caption{Vereinfachtes DB-Schema für die UDA}
		\label{fig:DBSchemaUDA}
	\end{center}
\end{wrapfigure}

Da wie schon erwähnt Software übernommen wird, so etwa die gesamte Hardwareabstraktion, muss auch die Datenbank an diesen Stellen übernommen werden. Um die Funktionalität der übernommenen Komponenten zu gewährleisten wurde eine DB Schema der bisherigen Datenbank so abgespeckt (Siehe Figure \ref{fig:DBSchemaUDA}), dass Sie für die UDA brauchbar ist.


Im Figure \ref{fig:DBSchemaUDA} wurden zusammengehörende Tabellen farblich zusammengelegt. Die Blau markierten Tabellen dienen dem einzelnen versuch. So werden alle Visuellen Kanäle in der Visual Tabelle abgelegt. Hinter diesem sichtbaren Kanal liegt ein Physikalischer Kanal, welche in der Physical Tabelle zu finden ist. An diesen Physikalischen Kanal sind die Meldeeinformationen, welche allesamt in der Grün Markierten Fläche zu finden sind, angeschlossen, sowie die Hardware Kommunikationsinformationen, welche allesamt in der Gelb Markierten Fläche zu finden sind, angeschlossen. In allem erhält man so einen Testaufbau, welcher Dynamisch aus vordefinierten Geräten sowie Hardware Abstraktionen zusammengesetzt werden kann, in dem man die Blau markierten Tabellen verändert.
\section{Projektergebnis}
Es konnte ein Skelett einer Neuen Datenerfassungssoftware erstellt werden, welche für in weiteren Schritten verbessert und erweitert wird. Die Software wurde schon nach dem ersten erfolgreichen Datenaufzeichnen Angewendet und wird im Moment für 2 Testaufbauten betrieben. Sie speichert die Daten persistent und erstellt auswertbare Excel Dateien, mit denen die Testdesigner Auswertungen zu den Tests machen können.
Eine Installationsanleitung erleichtert zudem die Installation, da die Anleitung Schritt für Schritt mit Bildern erklärt wird.
Die Softwaredokumentation sowie die Bedienungsanleitung wurden in Absprache mit den Vorgesetzten im Moment noch klein gehalten, da Sie zuerst das Skelett der Software wollten. Der Grund für die Schnelle Einführung der Software, war eine Anpassung einer UL Norm, welche dafür sorgte, dass die Melder mit einer Neuen Apparatur möglichst schon zu beginn des Projektes getestet werden sollten.

\section{Arbeitsjournal}
\begin{center}
	\begin{tabular}{p{6cm} | l | r}
		\textbf{Tätigkeit} & \textbf{Zeitraum} & \textbf{Aufwand} \\ &&\textbf{(t a 8h)}\\
		\hline Analyse der Anforderungen & W1 & 1 \\
		\hline Einarbeit in die Bestehende Software & W1 - W2 & 4 \\
		\hline Planung & W3 & 2.5 \\
		\hline SW-Design & W3-4 & 1.5 \\
		\hline DB-Modell & W4 & 1.5 \\
		\hline DB-Erstellen (Installieren und DB Modell umsetzten) & W4 - W5 & 1 \\
		\hline GUI Design & W5 & 2 \\
		\hline DB Kommunikation & W5 - W6 & 2.5 \\
		\hline Settings Screen (ini file Modifikation) & W6 - W7 & 2 \\
		\hline Channels Screen (anzeige von DB Info) & W7 & 1.5 \\
		\hline Graph Screen (ohne Kommunikation) & W8 - W9 & 4 \\
		\hline Recorder Implementation (Kommunikation zu Hardware Komponente) & W9 - W10 & 3.5 \\
		\hline Implementation Excel Export & W10 - W11 & 3 \\
		\hline Graph Screen Inbetriebnahme mit Kommunikation & W11 - W12 & 3 \\
		\hline Fertigstellung des Software Skelettes (Zusammenführen aller Komponente) & W13 & 2 \\
		\hline Installer erstellen & W13 - W14 & 1 \\
		\hline Inbetriebnahme (Gebrauch der Software mit Ankunft des neuen Aufbaus) & W14 & 3 \\
		\hline Installationsanleitung & W14 & 1 \\
		\hline SW-Dokumentation (beginn bei Planung wurde jeweils ergänzt und am Schluss nochmals zusammengetragen) & W14 & 0.5 \\\hhline{~--}
		& \textbf{Summe:} & \textbf{40.5} \\\hhline{~~=}
	\end{tabular}
\end{center}
\section{Fazit}
Für mich war und ist die UDA ein enorm grosses Projekt, welches mich sicher noch ein weiteres Jahr beschäftigen wird, da es noch viele Features zu implementieren gilt.

Ich muss jedoch gestehen, ich habe die Arbeit unterschätzt. Es gab ja Architektonisch schon eine Software von der ich Komponenten und Teile übernehmen konnte, so stellte mir \gls{LabVIEW} jedoch sehr viele Hindernisse in den Weg. Bei allen Objekte, welche ich von der bestehenden Software übernehmen wollte musste ich viele Teile der Software neu implementieren, da \gls{LabVIEW} viele Probleme mit Abhängigkeiten bereitete.

Weiter hatte ich einige Schwierigkeiten, bis ich das Aufzeichnen der Daten hingekriegt habe. Hier half jedoch, dass die Hardwarekomponenten schon klar eine Schnittstelle definiert hatten. Es dauerte jedoch sehr lange bis ich eine passende Lösung gefunden habe, da ich für die Integrität des Lesens, also das die Software wirklich immer in einem gewissen Zeitintervall die Daten speichert. Da ich in dieser Funktion einen eigenen Task erstellen musste und \gls{LabVIEW} hier auch so seine schwächen hat.

Als Fazit für mich muss ich leider sagen, dass ich für Projekte dieser Grössenordung dringend von \gls{LabVIEW} abrate. Man hat zwar schnell das Skelett des GUIs und eine gewisse Grundfunktionalität, jedoch lässt der Mangel an Wartbarkeit die Software Komplexität ins unermessliche steigen. Denn obwohl \gls{LabVIEW} inzwischen OOP und unit Tests kennt, sind diese nur unzureichend brauchbar.
\section{Bestätigung Arbeitgeber}
\begin{center}
	\begin{tabular}{p{5.5cm} p{5.5cm}}
		\textbf{Auftraggeber} \\\hline
		Firma & Siemens Schweiz AG \\
		Name, Vorname & Schmid, Urs \\
		Funktion & Head of FireLab \\
		Strasse, Hausnummer & Gubelstrasse 22 \\
		PLZ, Ort & 6300, Zug \\
		Telefon & +41 79 503 9712 \\
		Email & urs.schmid@siemens.com \\
		&  \\
		\textbf{Verfasser} \\\hline
		Firma & Siemens Schweiz AG \\
		Name, Vorname & Wicki, Dane \\
		Funktion & Werkstudent(Informatik) \\
		Strasse, Hausnummer & Gubelstrasse 22 \\
		PLZ, Ort & 6300, Zug \\
		Telefon & +41 79 503 5181 \\
		Email & dane.wicki@siemens.com \\
		& \\
		& \\
		\multicolumn{1}{l|}{Urs Schmid, Auftraggeber}  & Dane Wicki, Verfasser  \\
		\multicolumn{1}{l|}{} &  \\
		\multicolumn{1}{l|}{} &  \\
		\multicolumn{1}{l|}{} &  \\\hhline{--}
	\end{tabular}
\end{center}
\printbibliography
\appendix
\printglossaries
\end{document}
